<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KARATE FORM VR - Debug版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        #startButton,
        #nonVRButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            z-index: 100;
        }

        #nonVRButton {
            top: 60%;
            background: #2196F3;
        }

        #startButton:hover {
            background: #45a049;
        }

        #nonVRButton:hover {
            background: #1976D2;
        }

        #errorMessage {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 18px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            display: none;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 1);
            min-width: 400px;
        }
    </style>
</head>

<body>
    <!-- 音声要素を追加 -->
    <audio id="successSound" preload="auto">
        <source src="Quiz-Buzzer02-5(Multi).mp3" type="audio/mpeg">
    </audio>
    <audio id="failSound" preload="auto">
        <source src="Quiz-Ding_Dong02-1(Fast).mp3" type="audio/mpeg">
    </audio>

    <div id="info">VRモードでハンドトラッキングを表示</div>
    <div id="errorMessage"></div>
    <button id="startButton">VRモードを開始</button>
    <button id="nonVRButton">非VRモードで開始</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer;
        let hand1, hand2;
        let handMeshes = { left: [], right: [] };
        let headMesh;
        let targets = [];
        let isVRMode = false;
        let raycaster, mouse;
        let gltfLoader;
        let gltfModels = {}; // GLTFモデルを保存
        let availableGltfFiles = []; // 利用可能なGLTFファイルのリスト
        let lastSpawnTime = 0; // 最後にスポーンした時刻
        let spawnInterval = 6000; // スポーン間隔（ミリ秒）- 6秒に延長
        let spawnCount = 0; // スポーン回数をカウント

        // ポーズ判定用の変数
        let currentPose = null;
        let poseStartTime = null;
        let lastJudgmentTime = 0;
        const POSE_HOLD_TIME = 1500; // 1.5秒間ポーズを維持する必要がある
        const JUDGMENT_COOLDOWN = 3000; // 判定後3秒間は再判定しない

        // 音声要素の取得
        const successSound = document.getElementById('successSound');
        const failSound = document.getElementById('failSound');

        // 音声再生の準備（WebXR用）
        let audioContext = null;
        let audioInitialized = false;

        // VR空間内デバッグ表示用
        let debugTextGroup;
        let debugTexts = [];

        const HAND_JOINTS = [
            'wrist',
            'thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip',
            'index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip',
            'middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip',
            'ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip',
            'pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip'
        ];

        // 音声初期化関数
        async function initializeAudio() {
            if (audioInitialized) return;
            
            try {
                // Web Audio APIの初期化
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                audioInitialized = true;
                console.log('Audio initialized successfully');
            } catch (error) {
                console.warn('Audio initialization failed:', error);
            }
        }

        // 改良された音声再生関数
        async function playAudioSafe(audioElement) {
            try {
                // 音声の初期化
                await initializeAudio();
                
                // 音声要素のリセット
                audioElement.currentTime = 0;
                
                // 音量を設定
                audioElement.volume = 0.8;
                
                // 再生前にロード状態を確認
                if (audioElement.readyState < 2) {
                    console.log('Audio not ready, loading...');
                    await new Promise((resolve) => {
                        audioElement.addEventListener('canplaythrough', resolve, { once: true });
                        audioElement.load();
                    });
                }
                
                // 再生の試行
                const playPromise = audioElement.play();
                
                if (playPromise !== undefined) {
                    await playPromise;
                    console.log('Audio played successfully');
                } else {
                    console.log('Audio play method returned undefined');
                }
                
            } catch (error) {
                console.error('Audio play failed:', error);
                
                // フォールバック: Web Audio APIを使用
                try {
                    if (audioContext && audioContext.state === 'running') {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        // 成功音と失敗音を区別
                        const frequency = audioElement === successSound ? 800 : 400;
                        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                        
                        console.log('Fallback beep sound played');
                    }
                } catch (fallbackError) {
                    console.error('Fallback audio also failed:', fallbackError);
                }
            }
        }

        // VR空間内に3Dテキストを表示する関数
        function createDebugText(text, position, color = 0xffffff, size = 0.05) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 64;
            
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#000000';
            context.font = '32px Arial';
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(0.8, 0.1);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            
            return mesh;
        }

        // デバッグテキストの更新
        function updateDebugTexts(headPos, leftHandPos, rightHandPos, detectedPose) {
            // 既存のデバッグテキストを削除
            debugTexts.forEach(text => {
                debugTextGroup.remove(text);
            });
            debugTexts = [];

            if (!headPos || !leftHandPos || !rightHandPos) return;

            // 相対位置を計算
            const leftHandRelative = {
                x: leftHandPos.x - headPos.x,
                y: leftHandPos.y - headPos.y,
                z: leftHandPos.z - headPos.z
            };
            
            const rightHandRelative = {
                x: rightHandPos.x - headPos.x,
                y: rightHandPos.y - headPos.y,
                z: rightHandPos.z - headPos.z
            };

            // テキスト位置（プレイヤーの前方、左側に表示）
            const basePos = new THREE.Vector3(-1.5, 1.5, -2);
            
            // 座標情報を表示
            const texts = [
                `頭部: (${headPos.x.toFixed(2)}, ${headPos.y.toFixed(2)}, ${headPos.z.toFixed(2)})`,
                `左手: (${leftHandPos.x.toFixed(2)}, ${leftHandPos.y.toFixed(2)}, ${leftHandPos.z.toFixed(2)})`,
                `右手: (${rightHandPos.x.toFixed(2)}, ${rightHandPos.y.toFixed(2)}, ${rightHandPos.z.toFixed(2)})`,
                `左手相対: (${leftHandRelative.x.toFixed(2)}, ${leftHandRelative.y.toFixed(2)}, ${leftHandRelative.z.toFixed(2)})`,
                `右手相対: (${rightHandRelative.x.toFixed(2)}, ${rightHandRelative.y.toFixed(2)}, ${rightHandRelative.z.toFixed(2)})`,
                `検出ポーズ: ${detectedPose}`,
                `現在のポーズ: ${currentPose || 'なし'}`,
                `維持時間: ${poseStartTime ? ((Date.now() - poseStartTime) / 1000).toFixed(1) + 's' : '0s'}`
            ];

            texts.forEach((text, index) => {
                const position = new THREE.Vector3(basePos.x, basePos.y - index * 0.15, basePos.z);
                const color = index === 5 ? (detectedPose !== 'none' ? 0x00ff00 : 0xffffff) : 0xffffff;
                const debugText = createDebugText(text, position, color);
                debugTextGroup.add(debugText);
                debugTexts.push(debugText);
            });

            // 判定条件の詳細表示
            const punchConditions = checkPunchConditions(leftHandRelative, rightHandRelative);
            const standingConditions = checkStandingConditions(leftHandRelative, rightHandRelative);

            // パンチポーズの条件
            const punchTexts = [
                `右手前方: ${punchConditions.rightHandForward} (z < -0.3: ${rightHandRelative.z.toFixed(2)})`,
                `左手後方: ${punchConditions.leftHandBack} (z > -0.1: ${leftHandRelative.z.toFixed(2)})`,
                `右手高さ: ${punchConditions.rightHandHeight} (y > 0.8: ${rightHandRelative.y.toFixed(2)})`,
                `左手高さ: ${punchConditions.leftHandHeight} (y > 0.8: ${leftHandRelative.y.toFixed(2)})`,
                `右手右側: ${punchConditions.rightHandRight} (x > 0.05: ${rightHandRelative.x.toFixed(2)})`,
                `左手左側: ${punchConditions.leftHandLeft} (x < -1.0: ${leftHandRelative.x.toFixed(2)})`
            ];

            punchTexts.forEach((text, index) => {
                const position = new THREE.Vector3(basePos.x + 1.8, basePos.y - index * 0.12, basePos.z);
                const color = text.includes('true') ? 0x00ff00 : (text.includes('false') ? 0xff0000 : 0xffff00);
                const debugText = createDebugText(text, position, color, 0.04);
                debugTextGroup.add(debugText);
                debugTexts.push(debugText);
            });

            // 直立姿勢の条件表示を修正
            const standingTexts = [
                '=== 直立姿勢判定 ===',
                `左手下: ${standingConditions.leftHandDown} (y > 0.5: ${leftHandRelative.y.toFixed(2)})`,
                `右手下: ${standingConditions.rightHandDown} (y > 0.5: ${rightHandRelative.y.toFixed(2)})`,
                `左手左側: ${standingConditions.leftHandLeft} (x > -0.2: ${leftHandRelative.x.toFixed(2)})`,
                `右手右側: ${standingConditions.rightHandRight} (x < 0.2: ${rightHandRelative.x.toFixed(2)})`,
                `手が体に近い: ${standingConditions.handsNearBody} (|z| < 0.4: L=${Math.abs(leftHandRelative.z).toFixed(2)}, R=${Math.abs(rightHandRelative.z).toFixed(2)})`
            ];

            standingTexts.forEach((text, index) => {
                const position = new THREE.Vector3(basePos.x + 1.8, basePos.y - (index + 8) * 0.12, basePos.z);
                const color = text.includes('true') ? 0x00ff00 : (text.includes('false') ? 0xff0000 : 0xffff00);
                const debugText = createDebugText(text, position, color, 0.04);
                debugTextGroup.add(debugText);
                debugTexts.push(debugText);
            });
        }

        // パンチポーズの条件チェック
        function checkPunchConditions(leftHand, rightHand) {
            return {
                rightHandForward: rightHand.z < -0.3,
                leftHandBack: leftHand.z > -0.1,
                rightHandHeight: rightHand.y > 0.8,
                leftHandHeight: leftHand.y > 0.8,
                rightHandRight: rightHand.x > 0.05,
                leftHandLeft: leftHand.x < -1.0
            };
        }

        // 直立姿勢の条件チェック
        function checkStandingConditions(leftHand, rightHand) {
            return {
                leftHandDown: leftHand.y > 0.5,
                rightHandDown: rightHand.y > 0.5,
                leftHandLeft: leftHand.x > -0.2,
                rightHandRight: rightHand.x < 0.2,
                handsNearBody: Math.abs(leftHand.z) < 0.4 && Math.abs(rightHand.z) < 0.4
            };
        }

        // ポーズ判定関数
        function detectPose(headPos, leftHandPos, rightHandPos) {
            if (!headPos || !leftHandPos || !rightHandPos) return 'none';

            // 相対位置を計算（頭部を基準）
            const leftHandRelative = {
                x: leftHandPos.x - headPos.x,
                y: leftHandPos.y - headPos.y,
                z: leftHandPos.z - headPos.z
            };
            
            const rightHandRelative = {
                x: rightHandPos.x - headPos.x,
                y: rightHandPos.y - headPos.y,
                z: rightHandPos.z - headPos.z
            };
            
            // 空手パンチポーズの判定（横向きパンチ）
            const isPunchPose = detectPunchPose(leftHandRelative, rightHandRelative);
            
            // 直立姿勢の判定
            const isStandingPose = detectStandingPose(leftHandRelative, rightHandRelative);
            
            return isPunchPose ? 'punch' : isStandingPose ? 'standing' : 'none';
        }

        // パンチポーズの判定
        function detectPunchPose(leftHand, rightHand) {
            const conditions = checkPunchConditions(leftHand, rightHand);
            return Object.values(conditions).every(condition => condition);
        }

        // 直立姿勢の判定
        function detectStandingPose(leftHand, rightHand) {
            const conditions = checkStandingConditions(leftHand, rightHand);
            return Object.values(conditions).every(condition => condition);
        }

        // 判定結果の処理
        function processPoseJudgment(detectedPose) {
            const currentTime = Date.now();
            
            // クールダウン中は判定しない
            if (currentTime - lastJudgmentTime < JUDGMENT_COOLDOWN) {
                return;
            }
            
            if (detectedPose === currentPose) {
                // 同じポーズが継続している場合
                if (poseStartTime && currentTime - poseStartTime >= POSE_HOLD_TIME) {
                    // ポーズを十分な時間維持した場合
                    executeJudgment(detectedPose);
                    lastJudgmentTime = currentTime;
                    poseStartTime = null;
                    currentPose = null;
                }
            } else {
                // ポーズが変わった場合
                currentPose = detectedPose;
                poseStartTime = detectedPose !== 'none' ? currentTime : null;
            }
        }

        // 判定実行（修正版）
        async function executeJudgment(pose) {
            console.log(`Executing judgment for pose: ${pose}`);
            
            if (pose === 'punch') {
                // パンチポーズ成功
                console.log('Playing success sound for punch pose');
                await playAudioSafe(successSound);
                showJudgmentResult('パンチポーズ成功！', 'success');
            } else if (pose === 'standing') {
                // 直立姿勢成功
                console.log('Playing success sound for standing pose');
                await playAudioSafe(successSound);
                showJudgmentResult('直立姿勢成功！', 'success');
            }
        }

        // 判定結果の表示
        function showJudgmentResult(message, type) {
            // VR空間内に大きなメッセージを表示
            const position = new THREE.Vector3(0, 2, -2);
            const color = type === 'success' ? 0x00ff00 : 0xff0000;
            const resultText = createDebugText(message, position, color, 0.1);
            scene.add(resultText);
            
            // 3秒後に削除
            setTimeout(() => {
                scene.remove(resultText);
            }, 3000);
        }

        // ターゲットクラス
        class Target {
            constructor(gltfModel = null, type = 'front') {
                this.group = new THREE.Group();
                this.gltfModel = gltfModel;
                this.hit = false;
                this.type = type;
                this.speed = 0.05; // 移動速度を上げて突き抜けるアニメーションを強調
                this.collisionBalls = []; // 衝突判定用のボール
                this.headHit = false; // 頭部との衝突フラグ
                this.handHit = false; // 手との衝突フラグ
                this.judged = false; // 判定済みフラグ

                if (gltfModel) {
                    // GLTFモデルを使用
                    const modelClone = gltfModel.scene.clone();

                    // モデルのバウンディングボックスを計算
                    const box = new THREE.Box3().setFromObject(modelClone);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());

                    // モデルのサイズを正規化（高さ2ユニットに）
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0) {
                        const scale = 2 / maxDim;
                        modelClone.scale.set(scale, scale, scale);

                        // 中心を原点に移動
                        modelClone.position.x = -center.x * scale;
                        modelClone.position.y = -center.y * scale;
                        modelClone.position.z = -center.z * scale;
                    }

                    // モデルの可視性を確保
                    modelClone.traverse((child) => {
                        if (child.isMesh) {
                            child.visible = true;

                            // マテリアルが存在しない場合は作成
                            if (!child.material) {
                                child.material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                            }
                        }
                    });

                    // モデルをグループに追加
                    this.group.add(modelClone);

                    // 当たり判定用の球体を追加（透明）
                    const collisionGeometry = new THREE.SphereGeometry(1, 16, 16);
                    const collisionMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0,
                        wireframe: true
                    });
                    this.collisionMesh = new THREE.Mesh(collisionGeometry, collisionMaterial);
                    this.group.add(this.collisionMesh);

                    // 衝突判定用のボールを2つ追加
                    this.createCollisionBalls();
                }
            }

            createCollisionBalls() {
                // タイプに応じてボールの位置を変更
                if (this.type === 'front') {
                    // 元のfront.gltfの位置（デフォルト）
                    // ボール1（頭部用）- 透明
                    const ball1Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball1Material = new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x004400,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball1 = new THREE.Mesh(ball1Geometry, ball1Material);
                    ball1.position.set(0, 0.8, 0); // 頭部の高さ
                    ball1.userData = { type: 'head' };
                    this.group.add(ball1);
                    this.collisionBalls.push(ball1);

                    // ボール2（手用）- 透明
                    const ball2Geometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const ball2Material = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0x440000,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball2 = new THREE.Mesh(ball2Geometry, ball2Material);
                    ball2.position.set(0, 0.2, 0); // 胸部の高さ
                    ball2.userData = { type: 'hand' };
                    this.group.add(ball2);
                    this.collisionBalls.push(ball2);

                } else if (this.type === 'front_2') {
                    // front_2.gltfの位置（1枚目画像の通り）
                    // ボール1（頭部用）- 透明
                    const ball1Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball1Material = new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x004400,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball1 = new THREE.Mesh(ball1Geometry, ball1Material);
                    ball1.position.set(0.1, 0.7, 0); // 頭部の高さ（少し下に調整）
                    ball1.userData = { type: 'head' };
                    this.group.add(ball1);
                    this.collisionBalls.push(ball1);

                    // ボール2（手用）- 透明
                    const ball2Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball2Material = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0x440000,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball2 = new THREE.Mesh(ball2Geometry, ball2Material);
                    ball2.position.set(-0.3, 0.35, 0); // 左手の位置（右上に調整）
                    ball2.userData = { type: 'hand' };
                    this.group.add(ball2);
                    this.collisionBalls.push(ball2);

                    // ボール3（手用）- 透明
                    const ball3Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball3Material = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0x440000,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball3 = new THREE.Mesh(ball3Geometry, ball3Material);
                    ball3.position.set(0.4, 0, 0); // 右手の位置（上に調整）
                    ball3.userData = { type: 'hand' };
                    this.group.add(ball3);
                    this.collisionBalls.push(ball3);

                } else if (this.type === 'front_3') {
                    // front_3.gltfの位置（2枚目画像の通り）
                    // ボール1（頭部用）- 透明
                    const ball1Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball1Material = new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x004400,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball1 = new THREE.Mesh(ball1Geometry, ball1Material);
                    ball1.position.set(0.0, 0.7, 0); // 頭部の位置（右下に調整）
                    ball1.userData = { type: 'head' };
                    this.group.add(ball1);
                    this.collisionBalls.push(ball1);

                    // ボール2（手用）- 透明
                    const ball2Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball2Material = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0x440000,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball2 = new THREE.Mesh(ball2Geometry, ball2Material);
                    ball2.position.set(0.5, 0.5, 0); // 右手の位置（左上に調整）
                    ball2.userData = { type: 'hand' };
                    this.group.add(ball2);
                    this.collisionBalls.push(ball2);

                    // ボール3（手用）- 透明
                    const ball3Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball3Material = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0x440000,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball3 = new THREE.Mesh(ball3Geometry, ball3Material);
                    ball3.position.set(-0.6, 0.1, 0); // 左手の位置（上に調整）
                    ball3.userData = { type: 'hand' };
                    this.group.add(ball3);
                    this.collisionBalls.push(ball3);

                } else {
                    // その他のタイプ（sideなど）はデフォルト
                    // ボール1（頭部用）- 透明
                    const ball1Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball1Material = new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x004400,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball1 = new THREE.Mesh(ball1Geometry, ball1Material);
                    ball1.position.set(0, 0.8, 0); // 頭部の高さ
                    ball1.userData = { type: 'head' };
                    this.group.add(ball1);
                    this.collisionBalls.push(ball1);

                    // ボール2（手用）- 透明
                    const ball2Geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const ball2Material = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0x440000,
                        transparent: true,
                        opacity: 0 // 完全に透明
                    });
                    const ball2 = new THREE.Mesh(ball2Geometry, ball2Material);
                    ball2.position.set(0, 0.2, 0); // 胸部の高さ
                    ball2.userData = { type: 'hand' };
                    this.group.add(ball2);
                    this.collisionBalls.push(ball2);
                }
            }

            update(playerPosition) {
                if (this.hit) return;

                // タイプに応じて移動方向を決定
                if (this.type === 'side') {
                    // 右から左へ移動（X軸のマイナス方向）
                    this.group.position.x -= this.speed;
                } else {
                    // 後ろから前へ移動（Z軸のプラス方向）
                    this.group.position.z += this.speed;
                }

                // 画面外に出たかチェック
                if (this.type === 'side' && this.group.position.x < -10) {
                    this.performFinalJudgment();
                    this.hit = true; // 削除フラグを立てる
                } else if ((this.type === 'front' || this.type === 'front_2' || this.type === 'front_3') && this.group.position.z > 10) {
                    this.performFinalJudgment();
                    this.hit = true; // 削除フラグを立てる
                }
            }

            checkCollision() {
                if (this.hit || this.judged) return;

                // 頭部衝突フラグと手衝突フラグをリセット（1フレームごとに再チェック）
                let currentHeadHit = false;
                let currentHandHit = false;

                // 各ボールとの衝突をチェック
                this.collisionBalls.forEach(ball => {
                    const ballWorldPos = new THREE.Vector3();
                    ball.getWorldPosition(ballWorldPos);

                    // 頭部との衝突チェック
                    if (ball.userData.type === 'head' && headMesh) {
                        const headWorldPos = new THREE.Vector3();
                        headMesh.getWorldPosition(headWorldPos);
                        const distance = ballWorldPos.distanceTo(headWorldPos);
                        
                        if (distance < 0.4) { // 衝突距離
                            currentHeadHit = true;
                            if (!this.headHit) {
                                this.headHit = true;
                                // 衝突時の色変更は削除（透明なので意味がない）
                                console.log('Head collision detected! Distance:', distance);
                                
                                // 即座に音声を再生（テスト用）
                                playAudioSafe(successSound).catch(console.error);
                            }
                        }
                    }

                    // 手との衝突チェック
                    if (ball.userData.type === 'hand') {
                        let handCollided = false;
                        let minDistance = 999;

                        // 左手との衝突
                        if (handMeshes.left[0] && handMeshes.left[0].visible) {
                            const leftHandWorldPos = new THREE.Vector3();
                            handMeshes.left[0].getWorldPosition(leftHandWorldPos);
                            const distance = ballWorldPos.distanceTo(leftHandWorldPos);
                            minDistance = Math.min(minDistance, distance);
                            
                            if (distance < 0.4) { // 衝突距離
                                handCollided = true;
                            }
                        }

                        // 右手との衝突
                        if (handMeshes.right[0] && handMeshes.right[0].visible) {
                            const rightHandWorldPos = new THREE.Vector3();
                            handMeshes.right[0].getWorldPosition(rightHandWorldPos);
                            const distance = ballWorldPos.distanceTo(rightHandWorldPos);
                            minDistance = Math.min(minDistance, distance);
                            
                            if (distance < 0.4) { // 衝突距離
                                handCollided = true;
                            }
                        }

                        if (handCollided) {
                            currentHandHit = true;
                            if (!this.handHit) {
                                this.handHit = true;
                                // 衝突時の色変更は削除（透明なので意味がない）
                                console.log('Hand collision detected! Min distance:', minDistance);
                                
                                // 即座に音声を再生（テスト用）
                                playAudioSafe(failSound).catch(console.error);
                            }
                        }
                    }
                });

                // 複数の手用ボールがある場合、いずれか一つでも当たればhandHitをtrueにする
                if (currentHandHit) {
                    this.handHit = true;
                }
            }

            async performFinalJudgment() {
                if (this.judged) return;
                this.judged = true;

                console.log(`Final judgment - Head hit: ${this.headHit}, Hand hit: ${this.handHit}`);

                // 少し待ってから音声を再生
                setTimeout(async () => {
                    if (this.headHit && this.handHit) {
                        // 両方に衝突した場合は正解
                        console.log('Success: Both head and hand hit');
                        try {
                            await playAudioSafe(successSound);
                            showJudgmentResult('正解！両方に当たりました！', 'success');
                        } catch (error) {
                            console.error('Success sound failed:', error);
                            showJudgmentResult('正解！両方に当たりました！', 'success');
                        }
                    } else {
                        // どちらかまたは両方に衝突しなかった場合は不正解
                        console.log('Fail: Missing collision');
                        try {
                            await playAudioSafe(failSound);
                            const missedParts = [];
                            if (!this.headHit) missedParts.push('頭部');
                            if (!this.handHit) missedParts.push('手');
                            showJudgmentResult(`不正解！${missedParts.join('と')}に当たりませんでした`, 'fail');
                        } catch (error) {
                            console.error('Fail sound failed:', error);
                            const missedParts = [];
                            if (!this.headHit) missedParts.push('頭部');
                            if (!this.handHit) missedParts.push('手');
                            showJudgmentResult(`不正解！${missedParts.join('と')}に当たりませんでした`, 'fail');
                        }
                    }
                }, 100);
            }

            checkMatch() {
                // 従来の手との衝突判定は残しておく（互換性のため）
                if (!headMesh || this.hit || !this.gltfModel || !this.collisionMesh) return;

                const targetPos = new THREE.Vector3();
                this.collisionMesh.getWorldPosition(targetPos);

                // 手との距離をチェック（頭部との衝突は無視）
                let leftHandDist = 999;
                let rightHandDist = 999;

                if (handMeshes.left[0] && handMeshes.left[0].visible) {
                    leftHandDist = handMeshes.left[0].position.distanceTo(targetPos);
                }
                if (handMeshes.right[0] && handMeshes.right[0].visible) {
                    rightHandDist = handMeshes.right[0].position.distanceTo(targetPos);
                }

                const threshold = 0.5;
                // 手との衝突のみをチェック（頭部との衝突は除外）
                if (leftHandDist < threshold || rightHandDist < threshold) {
                    this.hit = true;
                }
            }
        }

        function init() {
            // Three.jsが完全にロードされているか確認
            if (typeof THREE === 'undefined' || !THREE.GLTFLoader) {
                console.error('Three.js or GLTFLoader not loaded yet');
                setTimeout(init, 100);
                return;
            }

            // GLTFローダーの初期化
            gltfLoader = new THREE.GLTFLoader();
            console.log('GLTFLoader initialized:', gltfLoader);

            // 利用可能なGLTFファイルをロード
            loadGLTFModels();

            // シーン作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101010);

            // カメラ（修正: より適切な高さに設定）
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 2); // 平均的な目線高さに修正

            // レンダラー
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // ライト - simple_gltf.htmlと同じ設定
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // 床
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // グリッド
            const gridHelper = new THREE.GridHelper(20, 20);
            scene.add(gridHelper);

            // デバッグテキスト用グループを作成
            debugTextGroup = new THREE.Group();
            scene.add(debugTextGroup);

            // ハンドトラッキングの設定
            hand1 = renderer.xr.getHand(0);
            hand2 = renderer.xr.getHand(1);

            scene.add(hand1);
            scene.add(hand2);

            // 手の関節用の球体を作成
            // 逆の割り当てを試す（hand1を右手、hand2を左手として）
            createHandJoints(hand1, 'right');
            createHandJoints(hand2, 'left');

            // 頭部の表示用メッシュを作成
            const headGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                roughness: 0.5,
                metalness: 0.3
            });
            headMesh = new THREE.Mesh(headGeometry, headMaterial);
            scene.add(headMesh);

            // VRモードボタンの設定
            document.getElementById('startButton').addEventListener('click', async () => {
                try {
                    // 音声の初期化（ユーザーインタラクション後）
                    await initializeAudio();
                    
                    // WebXRのサポートチェック
                    if (!navigator.xr) {
                        throw new Error('WebXRがサポートされていません');
                    }

                    // immersive-vrセッションのサポートチェック
                    const isVRSupported = await navigator.xr.isSessionSupported('immersive-vr');
                    if (!isVRSupported) {
                        throw new Error('VRセッションがサポートされていません');
                    }

                    // VRセッションを開始（ハンドトラッキング機能を要求）
                    const session = await navigator.xr.requestSession('immersive-vr', {
                        requiredFeatures: ['hand-tracking'],
                        optionalFeatures: ['local-floor', 'bounded-floor']
                    });

                    // セッションをレンダラーに設定
                    await renderer.xr.setSession(session);

                    // ボタンを非表示
                    document.getElementById('startButton').style.display = 'none';
                    document.getElementById('nonVRButton').style.display = 'none';
                    
                    isVRMode = true;

                } catch (error) {
                    console.error('VRセッションの開始に失敗:', error);
                    document.getElementById('errorMessage').textContent = 
                        `VRエラー: ${error.message}`;
                    document.getElementById('errorMessage').style.display = 'block';
                }
            });

            // 非VRモードボタンの設定
            document.getElementById('nonVRButton').addEventListener('click', async () => {
                // 音声の初期化（ユーザーインタラクション後）
                await initializeAudio();

                document.getElementById('startButton').style.display = 'none';
                document.getElementById('nonVRButton').style.display = 'none';
                document.getElementById('info').textContent = '非VRモード - クリックでターゲットを破壊';

                isVRMode = false;

                // Raycasterとマウスの初期化
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                // マウスクリックイベントの設定
                renderer.domElement.addEventListener('click', onMouseClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('mousedown', () => { isMouseDown = true; });
                renderer.domElement.addEventListener('mouseup', () => { isMouseDown = false; });
                renderer.domElement.addEventListener('mouseleave', () => { isMouseDown = false; });

                // 非VRモードでは頭部メッシュを非表示
                headMesh.visible = false;

                // カメラを少し後ろに
                camera.position.set(0, 1.8, 5);

                // ゲーム開始
                startNonVRGame();
            });

            // ウィンドウリサイズ
            window.addEventListener('resize', onWindowResize);
        }

        function createHandJoints(hand, handedness) {
            const jointMaterial = new THREE.MeshStandardMaterial({
                color: handedness === 'left' ? 0xff0000 : 0x0000ff,
                roughness: 0.5,
                metalness: 0.5
            });

            const jointGeometry = new THREE.SphereGeometry(0.01, 16, 16);

            for (let i = 0; i < HAND_JOINTS.length; i++) {
                const jointMesh = new THREE.Mesh(jointGeometry, jointMaterial);
                jointMesh.visible = false;
                hand.add(jointMesh);
                handMeshes[handedness].push(jointMesh);
            }
        }

        function updateHandJoints() {
            // 右手の更新（hand1）
            if (hand1.joints) {
                for (let i = 0; i < HAND_JOINTS.length; i++) {
                    const joint = hand1.joints[HAND_JOINTS[i]];
                    const mesh = handMeshes.right[i];

                    if (joint) {
                        mesh.position.copy(joint.position);
                        mesh.quaternion.copy(joint.quaternion);
                        mesh.visible = true;
                    } else {
                        mesh.visible = false;
                    }
                }
            }

            // 左手の更新（hand2）
            if (hand2.joints) {
                for (let i = 0; i < HAND_JOINTS.length; i++) {
                    const joint = hand2.joints[HAND_JOINTS[i]];
                    const mesh = handMeshes.left[i];

                    if (joint) {
                        mesh.position.copy(joint.position);
                        mesh.quaternion.copy(joint.quaternion);
                        mesh.visible = true;
                    } else {
                        mesh.visible = false;
                    }
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 手の座標を常に更新する関数
        function updateHandCoordinatesDisplay() {
            // 左手の座標（手首のメッシュ位置を取得）
            let leftHandPosStr = "未検出";
            let leftHandPos = null;
            if (handMeshes.left[0] && handMeshes.left[0].visible) {
                const wristMesh = handMeshes.left[0];
                leftHandPos = wristMesh.position;
                leftHandPosStr = `(${wristMesh.position.x.toFixed(2)}, ${wristMesh.position.y.toFixed(2)}, ${wristMesh.position.z.toFixed(2)})`;
            }

            // 右手の座標（手首のメッシュ位置を取得）
            let rightHandPosStr = "未検出";
            let rightHandPos = null;
            if (handMeshes.right[0] && handMeshes.right[0].visible) {
                const wristMesh = handMeshes.right[0];
                rightHandPos = wristMesh.position;
                rightHandPosStr = `(${wristMesh.position.x.toFixed(2)}, ${wristMesh.position.y.toFixed(2)}, ${wristMesh.position.z.toFixed(2)})`;
            }

            // 頭部の座標（修正: より正確な位置計算）
            let headPosStr = "未検出";
            let headPos = null;
            if (headMesh && renderer.xr.isPresenting) {
                // VRモード時のカメラ位置を使用
                const vrCamera = renderer.xr.getCamera(camera);
                headPos = vrCamera.position;
                headPosStr = `(${headPos.x.toFixed(2)}, ${headPos.y.toFixed(2)}, ${headPos.z.toFixed(2)})`;
            } else if (headMesh) {
                headPos = headMesh.position;
                headPosStr = `(${headMesh.position.x.toFixed(2)}, ${headMesh.position.y.toFixed(2)}, ${headMesh.position.z.toFixed(2)})`;
            }

            // ポーズ判定の実行とVR空間内デバッグ表示
            if (isVRMode && headPos && leftHandPos && rightHandPos) {
                const detectedPose = detectPose(headPos, leftHandPos, rightHandPos);
                processPoseJudgment(detectedPose);
                
                // VR空間内にデバッグ情報を表示
                updateDebugTexts(headPos, leftHandPos, rightHandPos, detectedPose);
            }

            // HTML情報表示を更新（非VRモード用）
            if (!isVRMode) {
                document.getElementById('info').innerHTML = `
                    <div style="line-height: 1.8;">
                        <div>非VRモード</div>
                        <div>頭部座標: <span style="color: #00ff00;">${headPosStr}</span></div>
                        <div>左手座標: <span style="color: #ff00ff;">${leftHandPosStr}</span></div>
                        <div>右手座標: <span style="color: #00ffff;">${rightHandPosStr}</span></div>
                    </div>
                `;
            }
        }

        // 非VRモード用の関数
        function startNonVRGame() {
            // ゲーム開始フラグ
            animate();
        }

        // マウス感度
        const mouseSensitivity = 0.002;
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 非VRモードでマウスドラッグ中の場合、カメラを回転
            if (!isVRMode && isMouseDown) {
                const deltaX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const deltaY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                // Y軸回転（左右を見る）
                camera.rotation.y -= deltaX * mouseSensitivity;

                // X軸回転（上下を見る）を制限付きで適用
                const newRotationX = camera.rotation.x - deltaY * mouseSensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, newRotationX));
            }
        }

        function onMouseClick(event) {
            // Raycasterを更新
            raycaster.setFromCamera(mouse, camera);

            // すべてのターゲットとの交差判定
            for (let target of targets) {
                const intersects = raycaster.intersectObjects(target.group.children);

                if (intersects.length > 0 && !target.hit) {
                    // ヒット処理
                    target.hit = true;

                    // ターゲットを非表示
                    target.group.visible = false;

                    break;
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            // VRモードの場合
            if (renderer.xr.isPresenting) {
                // ハンドトラッキングの更新
                updateHandJoints();

                // カメラの位置を頭部メッシュに反映（修正: より正確な位置設定）
                const vrCamera = renderer.xr.getCamera(camera);
                headMesh.position.copy(vrCamera.position);
                headMesh.position.y += 0.1; // 頭部メッシュを少し上に配置（調整値を小さくしました）
                headMesh.quaternion.copy(vrCamera.quaternion);
                isVRMode = true;

                // VRモードで常に手の座標を更新
                updateHandCoordinatesDisplay();
            }

            // ゲームロジック（VRモードと非VRモード共通）
            if (isVRMode || (!isVRMode && !renderer.xr.isPresenting)) {
                // 自動スポーン
                const currentTime = Date.now();
                if (currentTime - lastSpawnTime > spawnInterval && availableGltfFiles.length > 0) {
                    // front.gltf、front_2.gltf、front_3.gltf、side.gltfを順番にスポーン
                    const spawnOrder = ['front', 'front_2', 'front_3', 'side'];
                    const type = spawnOrder[spawnCount % spawnOrder.length];
                    spawnTestTarget(type);
                    lastSpawnTime = currentTime;
                    spawnCount++;
                }

                // プレイヤーの位置を取得（VRモードではカメラ位置、非VRモードでは固定位置）
                const playerPosition = isVRMode ? camera.position : new THREE.Vector3(0, 1.6, 0);

                // ターゲットの更新
                for (let i = targets.length - 1; i >= 0; i--) {
                    targets[i].update(playerPosition);
                    targets[i].checkCollision(); // 新しい衝突判定を追加
                    targets[i].checkMatch();

                    // ヒットしたターゲットを削除
                    if (targets[i].hit) {
                        scene.remove(targets[i].group);
                        targets.splice(i, 1);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // GLTFモデルをロード
        function loadGLTFModels() {
            const gltfFiles = ['front.gltf', 'front_2.gltf', 'front_3.gltf', 'side.gltf'];
            console.log('Loading GLTF files:', gltfFiles);

            gltfFiles.forEach(filename => {
                gltfLoader.load(
                    filename,
                    function (gltf) {
                        gltfModels[filename] = gltf;
                        availableGltfFiles.push(filename);
                        console.log(`${filename} loaded:`, gltf);

                        // モデルの情報を表示
                        const box = new THREE.Box3().setFromObject(gltf.scene);
                        const size = box.getSize(new THREE.Vector3());
                        console.log(`${filename} size:`, size);
                    },
                    function (xhr) {
                        console.log(`${filename}: ${(xhr.loaded / xhr.total * 100)}% loaded`);
                    },
                    function (error) {
                        console.error(`Error loading ${filename}:`, error);
                    }
                );
            });
        }

        // GLTFモデルをスポーンする関数
        function spawnTestTarget(type = 'front') {
            const filename = type + '.gltf';
            if (gltfModels[filename]) {
                const target = new Target(gltfModels[filename], type);
                scene.add(target.group);
                targets.push(target);

                // 位置設定
                if (type === 'side') {
                    // 真右から（プレイヤーの真横から）
                    target.group.position.set(8, 1.2, camera.position.z);
                    // Y軸方向に90度回転（左向きに）
                    target.group.rotation.y = Math.PI / 2;
                } else {
                    // front.gltf、front_2.gltf、front_3.gltfの全てに対応（前方から）
                    // VRモードでは手前から、非VRモードでは後ろから
                    const startZ = isVRMode ? camera.position.z - 8 : -10;
                    target.group.position.set(0, 1.2, startZ); 
                    // 回転なし（正面を向いたまま）
                }
                console.log(`Spawned: ${filename} at`, target.group.position);
            } else {
                console.log(`Model not loaded: ${filename}`);
            }
        }

        // キーボードショートカット（手動スポーン）
        window.addEventListener('keydown', (e) => {
            if (e.key === 'f') spawnTestTarget('front');     // 前方からスポーン
            if (e.key === 'g') spawnTestTarget('front_2');   // 前方からスポーン (front_2.gltf)
            if (e.key === 'h') spawnTestTarget('front_3');   // 前方からスポーン (front_3.gltf)
            if (e.key === 's') spawnTestTarget('side');      // 横からスポーン
        });

        // グローバルスコープに公開（デバッグ用）
        window.spawnTestTarget = spawnTestTarget;
        window.gltfModels = gltfModels;
        window.targets = targets;
        window.scene = scene;

        // 初期化と開始
        init();
        animate();
    </script>
</body>

</html>